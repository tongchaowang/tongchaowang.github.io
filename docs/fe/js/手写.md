# 手写

## 实现 apply、call、bind

```javascript
// apply
Function.prototype.apply = function (context, rest) {
  const ctx = context || window;
  const fn = Symbol("fn");
  ctx[fn] = this;
  return ctx[fn](...rest);
};

// call
Function.prototype.call = function (context, ...rest) {
  const ctx = context || window;
  const fn = Symbol("fn");
  ctx[fn] = this;
  return ctx[fn](...rest);
};

// bind
Function.prototype.bind = function (context, ...rest1) {
  const ctx = context || window;
  const fn = Symbol("fn");
  ctx[fn] = this;

  return function (...rest2) {
    const rest = [...rest1, ...rest2];
    return ctx[fn](...rest);
  };
};
```

## 实现 instanceOf

判断构造函数（right）的 prototype 属性是否出现在对象（left）的原型链中

```javascript
function myInstanceof(left, right) {
  // 对象原型
  let proto = Object.getPrototypeOf(left);
  // 构造函数的prototype对象
  const prototype = right.prototype;

  while (true) {
    if (!proto) return false;
    if (proto === prototype) return true;
    proto = Object.getPrototypeOf(proto);
  }
}
console.log(myInstanceof([], Array)); // true
console.log(myInstanceof("", String)); // true ???原生instacneof应该对基本类型单独做了处理
```

## 实现 new

1. 首先创建了一个新的空对象
2. 设置原型，将对象的原型设置为函数的 prototype 对象
3. 让函数的 this 指向这个对象，执行构造函数的代码
4. 判断函数的返回值类型，如果是值类型，返回创建的对象，如果是引用类型，就返回这个引用类型的对象

```javascript
function myNew(constructor, ...rest) {
  if (typeof constructor !== "function") {
    throw new TypeError("constructor is not a function");
  }
  const obj = Object.create(constructor.prototype);
  let result = null;
  result = constructor.apply(obj, rest);
  const flag =
    result && typeof result === "object" && typeof result === "function";
  return flag ? result : obj;
}
```

## 格式化 URL 参数

1. 去除开头?/#/&
2. 将字符串使用&分割
3. 将数组中每项使用=分割，并处理 name==1 情况
4. 若存在相同 key，将 val 转化为数组

```javascript
// 使用forEach
function parseQuery(search) {
  const result = {};
  // 去除开头?/#/&
  const query = search.replace(/^(\?|#|&)/, "");

  if (!query) {
    return result;
  }

  query.split("&").forEach((param) => {
    const [key, ...val] = param.split("=");
    const decodeKey = decodeURIComponent(key);
    // 处理a==1，转为{a: '=1'}
    const decodeVal = val.length ? decodeURIComponent(val.join("=")) : null;

    if (typeof result[decodeKey] === "undefined") {
      result[decodeKey] = decodeVal;
    } else if (Array.isArray(result[decodeKey])) {
      result[decodeKey].push(decodeVal);
    } else {
      result[decodeKey] = [result[decodeKey], decodeVal];
    }
  });

  return result;
}

//使用reduce
const parseQuery = (search) => {
  const query = search.replace(/^(\?|#|&)/, "");
  return query.split("&").reduce((param, it) => {
    // 防止为空时返回{"": "undefined"}
    if (it) {
      const [key, ...val] = it.split("=");
      const decodeKey = decodeURIComponent(key);
      // 处理a==1，转为{a: '=1'}
      const decodeVal = val.length ? decodeURIComponent(val.join("=")) : null;

      if (typeof param[decodeKey] === "undefined") {
        param[decodeKey] = decodeVal;
      } else if (Array.isArray(param[decodeKey])) {
        param[decodeKey] = param[decodeKey].push(decodeVal);
      } else {
        param[decodeKey] = [param[decodeKey], decodeVal];
      }
    }
    return param;
  }, {});
};

console.log(parseQuery("?a==1+&b=2&c=[3]&b=4&e&d="));
/**
{
  a: "=1+"
  b: ['2', '4']
  c: "[3]"
  d: ""
  e: null
}
*/
```

## 数组扁平化

## 函数柯理化

函数柯理化是将函数的多个参数转变为单个参数的方案，实际开发中最常使用的就是将函数参数进行缓存，之后再调用该函数时减少参数传递

```javascript
function curry(fn) {
  const { length } = fn;
  const curryNext =
    (args) =>
    (...rest) => {
      const argsNext = [...args, ...rest];
      console.log(argsNext);
      return argsNext.length === length ? fn(...argsNext) : curryNext(argsNext);
    };
  return curryNext([]);
}

function test(a, b, c) {
  return a + b + c;
}
console.log(test(1, 2, 3) === curry(test)(1)(2)(3)); // true
```
